<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlackTom&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0a3b45b57019fdb91526c8fbe5a2c425</icon>
  <subtitle>阳光洒肩头，仿佛自由身</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blacktomm.github.io/"/>
  <updated>2021-10-24T16:37:05.228Z</updated>
  <id>https://blacktomm.github.io/</id>
  
  <author>
    <name>Black Tom</name>
    <email>wtom1006@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-ioc-step-02-cglib</title>
    <link href="https://blacktomm.github.io/2021/09/14/spring-ioc-step-02-cglib/"/>
    <id>https://blacktomm.github.io/2021/09/14/spring-ioc-step-02-cglib/</id>
    <published>2021-09-13T16:35:24.000Z</published>
    <updated>2021-10-24T16:37:05.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p>cglib库的Enhancer在Spring AOP中作为一种生成代理的方式被广泛使用，它是一个字节码增强器，可以用来为无接口的类创建代理。它的功能与java自带的Proxy类挺相似的。它会根据某个给定的类创建子类，并且所有非final的方法都带有回调钩子。</p><h3 id="Enhancer类"><a href="#Enhancer类" class="headerlink" title="Enhancer类"></a>Enhancer类</h3><p>在CGLIB库中，<code>net.sf.cglib.proxy</code>包下面的类主要负责实现动态代理。其中，<strong>Enhancer</strong> 类是CGLIB实现动态代理的核心类。<strong>Enhancer</strong> 类通过创建被代理类的子类来实现动态代理。不同于JDK 1.3中基于接口实现的动态代理，CGLIB通过继承的方式实现动态代理，除此之外，CGLIB也支持基于接口的动态代理。相对JDK自带的Proxy动态代理，CGLIB提供的能力更加强大。</p><p>下面来看一个通过Enhancer类创建动态代理的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Foo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置被代理的类对象</span><br>        enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> CallbackImpl());<br>        Foo fooProxy = (Foo) enhancer.create();<br>        fooProxy.setName(<span class="hljs-string">"name"</span>);<br>        System.out.println(fooProxy.getName());<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName());<br>            <span class="hljs-keyword">return</span> proxy.invokeSuper(obj, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>ercept: setName<br><span class="hljs-built_in">int</span>ercept: getName<br>name<br></code></pre></td></tr></table></figure><p>上面的例子中，我们使用<strong>Enhancer</strong> 类的<code>enhancer.setSuperClass(Foo.class)</code>方法设置需要被代理的类，然后我们需要设置一个回调对象 <strong>Callback</strong> ，如果你熟悉JDK的Proxy代理实现的话，就会发现这个回调对象和 <strong>InvocationHandler</strong> 比较类似，确实这里的 <strong>Callback</strong> 对象做的作用和 <strong>InvocationHandler</strong> 是一样的，提供代理的逻辑。这里我们使用 <strong>MethodInterceptor</strong> 这个Callback实现类。CGLIB提供了一些不同的Callback实现，在后面我们会一一介绍，这里只要知道我们采用的是 <strong>MethodInterceptor</strong>。</p><p><strong>MethodInterceptor</strong> 接口中定义了一个<code>intercept(Object obj, Method method, Object[] args, MethodProxy proxy)</code>方法，我们可以通过实现这个方法来做具体的代理逻辑。<code>intercept</code>方法的第一个参数<code>obj</code>是创建的代理对象；<code>method</code>是被调用的具体的方法对象；<code>args</code>是方法调用的参数列表；<code>proxy</code>这个对象是对前面<code>method</code>方法的封装，可以通过<code>invokeSuper()</code>方便得调用父类（也就是我们要代理的类）的方法。</p><p><strong>Enhancer</strong> 类也提供了用于创建动态代理类的静态方法，比如上面例子中创建动态代理类的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>enhancer.setCallback(<span class="hljs-keyword">new</span> CallbackImpl());<br>Foo fooProxy = (Foo) enhancer.create();<br></code></pre></td></tr></table></figure><p>可以用<code>public static Object create(Class type, Callback callback)</code>静态方法代替：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Foo fooProxy = (Foo) Enhancer.create(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">CallbackImpl</span>())</span>;<br></code></pre></td></tr></table></figure><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>CGLIB的动态代理是基于继承来实现的，但是CGLIB也支持通过接口的方式来实现动态代理。CGLIB的 <strong>Ehancer</strong> 类提供了 <code>setInterfaces(Class[] interfaces)</code>方法，可以设置需要被代理的类实现的接口，通过这种方式，达到和JDK中Proxy一样的效果。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FooInterface.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FooInterface</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>;<br>     <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Foo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FooInterface</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置代理接口</span><br>        enhancer.setInterfaces(<span class="hljs-keyword">new</span> Class[] &#123;FooInterface<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>;<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> CallbackImpl());<br>        FooInterface fooProxy = (FooInterface) enhancer.create();<br>        fooProxy.setName(<span class="hljs-string">"name"</span>);<br>        System.out.println(fooProxy.getName());<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> FooInterface foo = <span class="hljs-keyword">new</span> Foo();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName());<br>            <span class="hljs-keyword">return</span> method.invoke(foo, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>ercept: setName<br><span class="hljs-built_in">int</span>ercept: getName<br>name<br></code></pre></td></tr></table></figure><p>通过 <strong>Enhancer</strong> 类的<code>setInterfaces()</code>方法，可以设置需要被代理的接口。如果你了解 JDK 1.3中的动态代理的话，可以发现在 <strong>CallbackImpl</strong> 中调用method的方式，和 <strong>InvocationHandler</strong> 是一样。特别的，CGLIB还提供了一个特殊的 <strong>Callback</strong> 类型<code>net.sf.cglib.proxy.InvocationHandler</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> java.lang.reflect.InvocationHandler&#125; replacement (unavailable under JDK 1.2).</span><br><span class="hljs-comment"> * This callback type is primarily for use by the &#123;<span class="hljs-doctag">@link</span> Proxy&#125; class but</span><br><span class="hljs-comment"> * may be used with &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; as well.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Neeme Praks &lt;a href="mailto:neeme@apache.org"&gt;neeme@apache.org&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> $Id: InvocationHandler.java,v 1.3 2004/06/24 21:15:20 herbyderby Exp $</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，CGLIB中的 <code>net.sf.cglib.proxy.InvocationHandler</code> 接口和 JDK 1.3中定义的 <code>java.lang.reflect.InvocationHandler</code> 定义的一样，也包含三个参数：<code>object</code>、<code>method</code>和<code>args</code>。同样的，在CGLIB包中的 <code>java.lang.reflect.InvocationHandler.invoke()</code> 方法中定义的这三个参数和JDK中定义的含义是一样的。上面的 <strong>CallbackImpl</strong> 实现如果替换成 <code>java.lang.reflect.InvocationHandler</code>，可以实现类似JDK 1.3的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  ....<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>      <span class="hljs-keyword">private</span> FooInterface foo = <span class="hljs-keyword">new</span> Foo();<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>          System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName());<br>          <span class="hljs-keyword">return</span> method.invoke(foo, args);<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合接口实现和子类继承"><a href="#组合接口实现和子类继承" class="headerlink" title="组合接口实现和子类继承"></a>组合接口实现和子类继承</h3><p>CGLIB的 <strong>Enhancer</strong> 类支持同时通过接口实现和继承的方式创建动态代理。也就是说，我们在创建动态代理的时候，可以同时设置 <strong>Enhancer</strong> 类的 <code>setSuperClass()</code>方法和 <code>setInterfaces()</code>方法。这种方式类似于Java中的类继承机制，可以同时处理接口实现和类继承。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FooInterface.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FooInterface</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>;<br>     <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Foo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FooInterface</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"foo"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <br>        enhancer.setInterfaces(<span class="hljs-keyword">new</span> Class[] &#123;FooInterface<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>;<br>        enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        <br>        enhancer.setCallback(<span class="hljs-keyword">new</span> CallbackImpl());<br>        <br>        Foo fooProxy = (Foo) enhancer.create();<br>        fooProxy.setName(<span class="hljs-string">"name"</span>);<br>        System.out.println(fooProxy.getName());<br>        fooProxy.foo();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> FooInterface foo = <span class="hljs-keyword">new</span> Foo();<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName());<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"getName"</span>)) &#123;<br>                <span class="hljs-keyword">return</span> methodProxy.invoke(foo, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"setName"</span>)) &#123;<br>                <span class="hljs-keyword">return</span> methodProxy.invokeSuper(proxy, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> methodProxy.invoke(foo, args);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">intercept:</span> <span class="hljs-string">setName</span><br><span class="hljs-attr">intercept:</span> <span class="hljs-string">getName</span><br><span class="hljs-literal">null</span><br><span class="hljs-attr">intercept:</span> <span class="hljs-string">foo</span><br><span class="hljs-string">foo</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们既通过<code>setSuperClass(Foo.class)</code>设置了动态代理类的父类是 <strong>Foo</strong> ，同时又通过<code>setInterfaces(new Class[] {FooInterface.class})</code>设置了动态代理类实现的接口。我们在Callback的实现中，调用<code>setName()</code>方法的时候，使用的是内部的foo对象，而<code>getName()</code>的时候调用的的是<code>methodProxy.invokeSuper()</code>，因为调用的不是同一个对象，所以<code>getName()</code>获取的值是null。</p><p>这个例子中，我们使用了<code>methodProxy.invoke()</code>方法，而不是上面 <strong>InvocationHandler</strong> 例子中的<code>method.invoke()</code>，<strong>InvocationHandler</strong> 中的<code>method.invoke()</code>是运用反射的方式来实现方法调用的，而CGLIB的<code>methodProxy.invoke()</code>是通过另外的FastClass的方式实现的，具体的细节由于篇幅限制，不在这里展开。</p><p>同样的，Enhancer类也提供了一个静态方法来简化创建动态代理的过程。</p><figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">Object</span> create(<span class="hljs-keyword">Class</span> superclass, <span class="hljs-keyword">Class</span>[] interfaces, Callback callback);<br></code></pre></td></tr></table></figure><h3 id="多个Callback对象"><a href="#多个Callback对象" class="headerlink" title="多个Callback对象"></a>多个Callback对象</h3><p>CGLIB支持同时定义多个 <strong>Callback</strong> 对象。<strong>Enhancer</strong> 类的<code>create</code>方法可以传递一个 <strong>Callback</strong> 数组，当指定多个 <strong>Callback</strong> 对象的时候，需要通过 <strong>CallbackFilter</strong> 类来分派不同的方法到不同的 <strong>Callback</strong> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CallbackFilter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Map a method to a callback.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the intercepted method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the index into the array of callbacks (as specified by &#123;<span class="hljs-doctag">@link</span> Enhancer#setCallbacks&#125;) to use for the method, </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(Method method)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The &lt;code&gt;CallbackFilter&lt;/code&gt; in use affects which cached class</span><br><span class="hljs-comment">     * the &lt;code&gt;Enhancer&lt;/code&gt; will use, so this is a reminder that</span><br><span class="hljs-comment">     * you should correctly implement &lt;code&gt;equals&lt;/code&gt; and</span><br><span class="hljs-comment">     * &lt;code&gt;hashCode&lt;/code&gt; for custom &lt;code&gt;CallbackFilter&lt;/code&gt;</span><br><span class="hljs-comment">     * implementations in order to improve performance.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CGLIB提供了一个Callback对象过滤器：<strong>CallbackFilter</strong> ，该类提供了一个<code>accept()</code>方法，该方法返回的是提供的 <strong>Callback</strong> 数组的下标。通过 <strong>CallbackFilter</strong> 可以将拦截的请求分派到不同的 <strong>Callback</strong> 对象中。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Foo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        enhancer.setCallbacks(<span class="hljs-keyword">new</span> Callback[] &#123;<span class="hljs-keyword">new</span> CallbackImpl1(), <span class="hljs-keyword">new</span> CallbackImpl2()&#125;);<br>        enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> CallbackFilterImpl());<br>        Foo fooProxy = (Foo) enhancer.create();<br>        fooProxy.setName(<span class="hljs-string">"name"</span>);<br>        System.out.println(fooProxy.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackFilterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CallbackFilter</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"setName"</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> methodProxy.invokeSuper(proxy, args);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> proxy.invokeSuper(obj, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们用 <strong>CallbackFilterImpl</strong> 实现了一个Callback的过滤器，通过返回Callback对象的下标将拦截到的请求分派到不同的Callback实现类： <strong>CallbackImpl1</strong> 和 <strong>CallbackImpl2</strong> 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks)</span></span>;<br></code></pre></td></tr></table></figure><p>CGLIB也提供了一个静态方法来创建支持Callback对象拦截器的动态代理对象。</p><h3 id="动态代理Class对象"><a href="#动态代理Class对象" class="headerlink" title="动态代理Class对象"></a>动态代理Class对象</h3><p>上面我们了解了如何通过 <strong>Enhancer</strong> 创建一个动态代理对象。有时候，我们处于性能或者延迟创建动态代理对象的考虑，我们需要创建一个动态代理类对象，然后将这个类对象缓存起来，等到需要的时候再通过这个类对象创建需要的动态代理类。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Foo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        enhancer.setCallbackTypes(<span class="hljs-keyword">new</span> Class[] &#123;CallbackImpl1<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">CallbackImpl2</span>.<span class="hljs-title">class</span>&#125;)</span>;<br>        enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> CallbackFilterImpl());<br><br>        Class clazz = enhancer.createClass();<br>        Enhancer.registerCallbacks(clazz, <span class="hljs-keyword">new</span> Callback[] &#123;<span class="hljs-keyword">new</span> CallbackImpl1(), <span class="hljs-keyword">new</span> CallbackImpl2()&#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Foo fooProxy = (Foo) clazz.newInstance();<br>            fooProxy.setName(<span class="hljs-string">"name"</span>);<br>            System.out.println(fooProxy.getName());<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException ignore) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackFilterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CallbackFilter</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"setName"</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> methodProxy.invokeSuper(proxy, args);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> proxy.invokeSuper(obj, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">intercept: setName <span class="hljs-keyword">in</span>: org<span class="hljs-selector-class">.learn</span><span class="hljs-selector-class">.agent</span>.Foo<span class="hljs-variable">$CallbackImpl1</span><br>intercept: getName <span class="hljs-keyword">in</span>: org<span class="hljs-selector-class">.learn</span><span class="hljs-selector-class">.agent</span>.Foo<span class="hljs-variable">$CallbackImpl2</span><br>name<br></code></pre></td></tr></table></figure><p>我们首先通过<code>Enhancer enhancer = new Enhancer()</code>创建一个Enhancer对象，然后和之前一样，我们对这个enhancer对象调用<code>enhancer.setSuperClass()</code>来设置需要被代理的类对象。然后通过<code>enhancer.setCallbackTypes()</code>设置所有拦截器的类型。这里我们设置了多个拦截器Callback，所以需要通过<code>enhancer.setCallbackFilter()</code>设置一个拦截器过滤器CallbackFilter来处理拦截请求的分派。如果设置的拦截器只有一个，那设置过滤器的这一步可以省略。然后我们通过调用<code>enhancer.createClass()</code>创建一个代理类的类对象。创建完类对象以后，我们还需要把拦截器对象通过<code>registerCallbacks()</code>注册到这个动态代理类对象上面。然后我们通过反射的方式，用这个动态代理类对象创建了一个动态代理对象。</p><p>需要注意的一点是，我们在上面的代码中，通过<code>registerCallbacks()</code>注册到动态代理类对象的拦截器，只会影响到注册这些拦截器的线程，如果这个动态代理类对象被别的线程使用，那么这些拦截器不会起作用。不过 <strong>Enhancer</strong> 类提供了另外一个方法<code>registerStaticCallbacks()</code>，这个方式注册的拦截器可以被所有线程共享。</p><h3 id="CallbackHelper"><a href="#CallbackHelper" class="headerlink" title="CallbackHelper"></a>CallbackHelper</h3><p>当我们的拦截器 <strong>Callback</strong> 对象有多个的时候，我们创建一个 <strong>CallbackFilter</strong> 对象来处理拦截请求的分派。我们上面的例子中， <strong>CallbackFilterImpl</strong> 的实现中通过设置上下文中定义的拦截器 <strong>Callback</strong> 数组的下标来确定不同的拦截器对象。这种方式既容易出错，也比较繁琐。CGLIB提供了一个 <strong>CallbackHelper</strong> 帮助对象，它其实一个实现了 <strong>CallbackFilter</strong> 接口的抽象类型，使用者只要继承这个抽象类，然后实现 <code>getCallback(Method)</code>方法，通过入参提供的每个需要被拦截的方法，提供不同的Callback对象。利用这个方法，可以获取到所有需要使用到的拦截器，然后可以通过<code>getCallbacks()</code>获取所有的拦截器对象，也可以通过<code>getCallbackTypes()</code>获取到所有拦截器的类型，可以很方便得给Enhancer对象提供需要的参数，而对拦截器的定义统一放在这个帮助类中。</p><p>上面的多拦截器的例子，可以用 <strong>CallbackHelper</strong> 实现同样的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        CallbackHelper callbackHelper = <span class="hljs-keyword">new</span> CallbackHelperImpl(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">null</span>)</span>;<br>        <br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        enhancer.setSuperclass(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        enhancer.setCallbackTypes(callbackHelper.getCallbackTypes());<br>        enhancer.setCallbackFilter(callbackHelper);<br><br>        Class clazz = enhancer.createClass();<br>        Enhancer.registerCallbacks(clazz, callbackHelper.getCallbacks());<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Foo fooProxy = (Foo) clazz.newInstance();<br>            fooProxy.setName(<span class="hljs-string">"name"</span>);<br>            System.out.println(fooProxy.getName());<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException ignore) &#123;<br><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackHelperImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallbackHelper</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallbackHelperImpl</span><span class="hljs-params">(Class superclass, Class[] interfaces)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(superclass, interfaces);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getCallback</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"setName"</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallbackImpl1();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallbackImpl2();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> methodProxy.invokeSuper(proxy, args);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            System.out.println(<span class="hljs-string">"intercept: "</span> + method.getName() + <span class="hljs-string">" in: "</span> + getClass().getName());<br>            <span class="hljs-keyword">return</span> proxy.invokeSuper(obj, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Callback类型"><a href="#Callback类型" class="headerlink" title="Callback类型"></a>Callback类型</h2><p>除了我们上面介绍的 <strong>MethodInterceptor</strong> 和 <strong>InvocationHandler</strong> 这两种类型的拦截器，CGLIB还提供了一些其他类型的拦截器，可以用于特定的场景。</p><h3 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h3><p><strong>MethodInterceptor</strong> 是我们在上文介绍中使用的拦截器，这个拦截器是CGLIB中最通用的拦截器类型，它的作用比较简单，就是拦截方法调用，可以用于实现在AOP中的环绕增强方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * General-purpose &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback which provides for "around advice".</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juozas Baliuka &lt;a href="mailto:baliuka@mwm.lt"&gt;baliuka@mwm.lt&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * All generated proxied methods call this method instead of the original method.</span><br><span class="hljs-comment">     * The original method may either be invoked by normal reflection using the Method object,</span><br><span class="hljs-comment">     * or by using the MethodProxy (faster).</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj "this", the enhanced object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method intercepted Method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args argument array; primitive types are wrapped</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span><br><span class="hljs-comment">     * as many times as needed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MethodProxy</span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="hljs-function"><span class="hljs-params">                               MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个拦截器的使用我们在上文中已经介绍了很多了，这里就不再单独介绍了。</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p><strong>InvocationHandler</strong> 拦截器的作用和上面的 <strong>MethodInterceptor</strong> 一样，是一个通用的方法拦截器。唯一的不同是，这个拦截器类型是对JDK的动态代理实现 <strong>InvocationHandler</strong> 的替换，JDK的动态代理可以选择使用CGLIB中的这个 <strong>InvocationHandler</strong> 拦截器类型，也可以在Enhancer类中使用这个拦截器，实现和Proxy一样的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> java.lang.reflect.InvocationHandler&#125; replacement (unavailable under JDK 1.2).</span><br><span class="hljs-comment"> * This callback type is primarily for use by the &#123;<span class="hljs-doctag">@link</span> Proxy&#125; class but</span><br><span class="hljs-comment"> * may be used with &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; as well.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Neeme Praks &lt;a href="mailto:neeme@apache.org"&gt;neeme@apache.org&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> $Id: InvocationHandler.java,v 1.3 2004/06/24 21:15:20 herbyderby Exp $</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FixedValue"><a href="#FixedValue" class="headerlink" title="FixedValue"></a>FixedValue</h3><p><strong>FixedValue</strong> 这个拦截器类型和它命名含义一样，会对所有的方法调用返回一个固定的值。这个拦截器只有一个<code>loadObject()</code>方法，在实现这个拦截器的时候，需要返回和被拦截的方法的返回值类型相兼容的类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback that simply returns the value to return</span><br><span class="hljs-comment"> * from the proxied method. No information about what method</span><br><span class="hljs-comment"> * is being called is available to the callback, and the type of</span><br><span class="hljs-comment"> * the returned object must be compatible with the return type of</span><br><span class="hljs-comment"> * the proxied method. This makes this callback primarily useful</span><br><span class="hljs-comment"> * for forcing a particular method (through the use of a &#123;<span class="hljs-doctag">@link</span> CallbackFilter&#125;</span><br><span class="hljs-comment"> * to return a fixed value with little overhead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FixedValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the object which the original method invocation should</span><br><span class="hljs-comment">     * return. This method is called for &lt;b&gt;every&lt;/b&gt; method invocation.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an object matching the type of the return value for every</span><br><span class="hljs-comment">     * method this callback is mapped to</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FixedValue</strong> 拦截器使用也比较简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Foo fooProxy = (Foo) Enhancer.create(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">FixedValueImpl</span>())</span>;<br>        fooProxy.setName(<span class="hljs-string">"new name"</span>);<br>        System.out.println(fooProxy.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedValueImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FixedValue</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"default"</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><p>可以看到，调用<code>fooProxy.getName()</code>的时候，由于 <strong>FixedValue</strong> 的作用，原先通过<code>setName</code>设置的值被覆盖了。</p><h3 id="LazyLoader"><a href="#LazyLoader" class="headerlink" title="LazyLoader"></a>LazyLoader</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Lazy-loading &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LazyLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the object which the original method invocation should be</span><br><span class="hljs-comment">     * dispatched. Called as soon as the first lazily-loaded method in</span><br><span class="hljs-comment">     * the enhanced instance is invoked. The same object is then used</span><br><span class="hljs-comment">     * for every future method call to the proxy instance.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an object that can invoke the method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LazyLoader</strong> 这个Callback的作用是实现延迟加载，<code>LazyLoader</code>接口中只包含了一个<code>loadObject()</code>方法，当第一次调用设置了这个拦截器的动态代理对象的时候，CGLIB会调用这个<code>loadObject()</code>方法获取方法调用实际需要被分派的对象，之后所有拦截到的方法调用都会分派给这个返回的对象。也就是说<code>loadObject()</code>方法只会被调用一次，后续所有的请求都会分派给这个返回的对象。</p><p><strong>LazyLoader</strong> 不同于前面介绍的 <strong>MethodInterceptor</strong> ，在 <strong>MethodInterceptor</strong> 中处理的是方法调用的分派细节，可以控制调用实际对象的前后逻辑，而 <strong>LazyLoader</strong> 关注的是实际方法调用被分派的对象，不关心方法调用前后的控制。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Foo fooProxy = (Foo) Enhancer.create(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">LazyLoaderImpl</span>())</span>;<br>        fooProxy.setName(<span class="hljs-string">"new name 1"</span>);<br>        fooProxy.setName(<span class="hljs-string">"new name 2"</span>);<br>        System.out.println(fooProxy.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyLoaderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LazyLoader</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            System.out.println(<span class="hljs-string">"lazy load object"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">lazy <span class="hljs-keyword">load</span> <span class="hljs-keyword">object</span><br><span class="hljs-built_in">new</span> <span class="hljs-type">name</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>从结果中我们也可以看到，虽然我们调用了两次<code>fooProxy.setName()</code>，但是实际<code>LazyLoader.loadObject()</code>只执行了一次。<code>loadObject()</code>的返回值被CGLIB缓存了起来，下次所有拦截到的方法都分派给了这个对象。</p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Dispatching &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback. This is identical to the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> LazyLoader&#125; interface but needs to be separate so that &lt;code&gt;Enhancer&lt;/code&gt;</span><br><span class="hljs-comment"> * knows which type of code to generate.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the object which the original method invocation should</span><br><span class="hljs-comment">     * be dispatched. This method is called for &lt;b&gt;every&lt;/b&gt; method invocation.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an object that can invoke the method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Dispatcher</strong> 和 <strong>LazyLoader</strong> 类似，接口中只有一个<code>loadObject()</code>方法，唯一的区别是：每次方法调用， <strong>Dispatcher</strong> 的<code>loadObject()</code>方法都会执行，并且返回一个新的对象，而 <strong>LazyLoader</strong> 只会执行一次<code>loadObject()</code>方法。</p><p><strong>Dispatcher</strong> 可以用于请求的分派，实现类似于OO里面多态的特性，但是可以控制并决定实际分派的目标对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ...args)</span> </span>&#123;<br>        Foo fooProxy = (Foo) Enhancer.create(Foo<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">DispatcherImpl</span>())</span>;<br>        fooProxy.setName(<span class="hljs-string">"new name 1"</span>);<br>        fooProxy.setName(<span class="hljs-string">"new name 2"</span>);<br>        System.out.println(fooProxy.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            System.out.println(<span class="hljs-string">"dispatch"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">dispatch</span><br><span class="hljs-built_in">dispatch</span><br><span class="hljs-built_in">dispatch</span><br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>可以看到，对代理对象的每次方法调用都会执行<code>Dispatcher.loadObject()</code>方法，而且从输出中可以看到，由于每次调用都是作用于新的对象，所以最后一次的<code>getName()</code>调用和之前的<code>setName()</code>调用分派的是不同的对象，导致最后输出的结果数<code>null</code>。</p><h3 id="ProxyRefDispatcher"><a href="#ProxyRefDispatcher" class="headerlink" title="ProxyRefDispatcher"></a>ProxyRefDispatcher</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Dispatching &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback. This is the same as the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Dispatcher&#125; except for the addition of an argument</span><br><span class="hljs-comment"> * which references the proxy object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProxyRefDispatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the object which the original method invocation should</span><br><span class="hljs-comment">     * be dispatched. This method is called for &lt;b&gt;every&lt;/b&gt; method invocation.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy a reference to the proxy (generated) object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an object that can invoke the method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">loadObject</span><span class="hljs-params">(Object proxy)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ProxyRefDispatcher</strong> 这个拦截器类型实现的功能和 <strong>Dispatcher</strong> 类似，也是用于方法调用的分派。但是 <strong>ProxyRefDispatcher</strong> 这个拦截器类型定义了一个带参数的<code>loadObject()</code>方法，方法中的<code>proxy</code>参数是对代理对象的引用。</p><h3 id="NoOp"><a href="#NoOp" class="headerlink" title="NoOp"></a>NoOp</h3><p>这个拦截器类型和它的名字一样，什么也不做。所有的请求都会直接分派给被代理的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Methods using this &#123;<span class="hljs-doctag">@link</span> Enhancer&#125; callback will delegate directly to the</span><br><span class="hljs-comment"> * default (super) implementation in the base class.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoOp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A thread-safe singleton instance of the &lt;code&gt;NoOp&lt;/code&gt; callback.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> NoOp INSTANCE = <span class="hljs-keyword">new</span> NoOp() &#123; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何利用CGLIB的<code>net.sf.cglib.proxy</code>包实现动态代理，介绍了Enhancer类和API的使用，最后对所有Callback类型的功能和特性逐个进行了介绍。动态代理只是CGLIB这个工具包提供了其中一项功能，除了本文介绍的动态代理，它还可以处理Bean对象和实现反射，下次我们介绍下如何利用CGLIB进行反射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.baeldung.com/cglib" target="_blank" rel="noopener">Introduction to cglib</a></li><li><a href="https://www.jianshu.com/p/20203286ccd9" target="_blank" rel="noopener">cglib demo以及Enhancer源码解析</a></li><li><a href="https://www.runoob.com/w3cnote/cglibcode-generation-library-intro.html" target="_blank" rel="noopener">CGLIB(Code Generation Library) 介绍与原理</a></li><li><a href="https://tech101.cn/2019/04/20/%E4%BD%BF%E7%94%A8CGLIB_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">使用CGLIB--动态代理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cglib&quot;&gt;&lt;a href=&quot;#Cglib&quot; class=&quot;headerlink&quot; title=&quot;Cglib&quot;&gt;&lt;/a&gt;Cglib&lt;/h2&gt;&lt;p&gt;cglib库的Enhancer在Spring AOP中作为一种生成代理的方式被广泛使用，它是一个字节码增强器，可以用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring-ioc-step-reflection</title>
    <link href="https://blacktomm.github.io/2021/09/09/spring-ioc-step-02-reflection/"/>
    <id>https://blacktomm.github.io/2021/09/09/spring-ioc-step-02-reflection/</id>
    <published>2021-09-08T16:33:25.000Z</published>
    <updated>2021-10-24T16:35:43.700Z</updated>
    
    <content type="html"><![CDATA[<p>spring容器本身不仅涵盖 bean 的获取，还承担着bean的创建，而后者主要利用了 Java反射与 Cglib提供的 API，根据运行时传入的类信息来创建实例，此外两者还可用用于动态代理。</p><h3 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h3><p>Java 反射不仅可以用于创建对象实例，也可以获取类属性、方法、构造器等，从而修改对象属性。以下为一个简单示例</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取类属性"><a href="#获取类属性" class="headerlink" title="获取类属性"></a>获取类属性</h4><p>调用getClass方法可以获取到对象类信息，从而通过getDeclaredFields方法可以得到类属性Field</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenObject_whenGetsFieldNamesAtRuntime_thenCorrect</span><span class="hljs-params">()</span> </span>&#123;<br>    Object person = <span class="hljs-keyword">new</span> Person();<br>    Field[] fields = person.getClass().getDeclaredFields();<br><br>    List&lt;String&gt; actualFieldNames = getFieldNames(fields);<br><br>    assertTrue(Arrays.asList(<span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>)<br>      .containsAll(actualFieldNames));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getFieldNames</span><span class="hljs-params">(Field[] fields)</span> </span>&#123;<br>    List&lt;String&gt; fieldNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Field field : fields)<br>      fieldNames.add(field.getName());<br>    <span class="hljs-keyword">return</span> fieldNames;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 Field 包含众多的属性，field.getName()即对应Field其中一个属性</p><p><img src="https://blog-field-1258773891.cos.ap-beijing.myqcloud.com/record/2021%20/10/%2024/image-20211024220711097.png" alt="image-20211024220711097"></p><h4 id="获取类方法"><a href="#获取类方法" class="headerlink" title="获取类方法"></a>获取类方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenClass_whenGetsMethods_thenCorrect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    Class&lt;?&gt; animalClass = Class.forName(<span class="hljs-string">"com.code.springframework.beans.Person"</span>);<br>    Method[] methods = animalClass.getDeclaredMethods();<br>    List&lt;String&gt; actualMethods = getMethodNames(methods);<br><br>    assertEquals(<span class="hljs-number">2</span>, actualMethods.size());<br>    assertTrue(actualMethods.containsAll(Arrays.asList(<span class="hljs-string">"getName"</span>,<br>        <span class="hljs-string">"setName"</span>)));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getMethodNames</span><span class="hljs-params">(Method[] methods)</span> </span>&#123;<br>    List&lt;String&gt; methodNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Method method : methods)<br>      methodNames.add(method.getName());<br>    <span class="hljs-keyword">return</span> methodNames;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建类实例"><a href="#创建类实例" class="headerlink" title="创建类实例"></a>创建类实例</h4><p>反射既可以创建无参构造函数，也可以创建含参构造函数，通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法即可创建对象实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenClass_whenInstantiatesObjectsAtRuntime_thenCorrect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;<br>    Class&lt;?&gt; personClazz = Class.forName(<span class="hljs-string">"com.code.springframework.beans.Person"</span>);<br>    Constructor&lt;?&gt; cons1 = personClazz.getConstructor();<br>    Constructor&lt;?&gt; cons2 = personClazz.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>    Constructor&lt;?&gt; cons3 = personClazz.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;<br><br>    Person person1 = (Person) cons1.newInstance();<br>    Person person2 = (Person) cons2.newInstance(<span class="hljs-string">"tom"</span>);<br>    Person person3 = (Person) cons3.newInstance(<span class="hljs-string">"tom"</span>, <span class="hljs-number">3</span>);<br><br>    assertEquals(<span class="hljs-keyword">null</span>, person1.getName());<br>    assertEquals(<span class="hljs-string">"tom"</span>, person2.getName());<br>    assertEquals(<span class="hljs-string">"tom"</span>, person3.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 会返回指定定参数类型的所有构造器，包括public的和private的；<code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>只返回制定参数类型访问权限是public的构造器；而<code>getDeclaredConstructors()</code>与<code>getConstructors()</code>的返回结果均没有参数类型过滤。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">大白话说Java反射：入门、使用、原理</a></li><li><a href="https://www.baeldung.com/java-reflection" target="_blank" rel="noopener">Guide to Java Reflection</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring容器本身不仅涵盖 bean 的获取，还承担着bean的创建，而后者主要利用了 Java反射与 Cglib提供的 API，根据运行时传入的类信息来创建实例，此外两者还可用用于动态代理。&lt;/p&gt;
&lt;h3 id=&quot;Java-反射&quot;&gt;&lt;a href=&quot;#Java-反射&quot;
      
    
    </summary>
    
    
      <category term="Java Reflection" scheme="https://blacktomm.github.io/categories/Java-Reflection/"/>
    
    
  </entry>
  
  <entry>
    <title>guaua-cache-guide</title>
    <link href="https://blacktomm.github.io/2021/09/03/guaua-cache-guide/"/>
    <id>https://blacktomm.github.io/2021/09/03/guaua-cache-guide/</id>
    <published>2021-09-02T17:24:02.000Z</published>
    <updated>2021-09-09T17:27:14.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存分为本地缓存和远端缓存。常见的远端缓存有Redis，MongoDB；本地缓存一般使用map的方式保存在本地内存中。一般我们在业务中操作缓存，都会操作缓存和数据源两部分。如：put数据时，先插入DB，再删除原来的缓存；ge数据时，先查缓存，命中则返回，没有命中时，需要查询DB，再把查询结果放入缓存中 。如果访问量大，我们还得兼顾本地缓存的线程安全问题。必要的时候也要考虑缓存的回收策略。</p><p>今天说的 Guava Cache 是google guava中的一个内存缓存模块，用于将数据缓存到JVM内存中。他很好的解决了上面提到的几个问题：</p><ul><li>很好的封装了get、put操作，能够集成数据源 ；</li><li>线程安全的缓存，与ConcurrentMap相似，但前者增加了更多的元素失效策略，后者只能显示的移除元素；</li><li>Guava Cache提供了三种基本的缓存回收方式：基于容量回收、定时回收和基于引用回收。定时回收有两种：按照写入时间，最早写入的最先回收；按照访问时间，最早访问的最早回收；</li><li>监控缓存加载/命中情况</li></ul><p>Guava Cache的架构设计灵感ConcurrentHashMap，在简单场景中可以通过HashMap实现简单数据缓存，但如果要实现缓存随时间改变、存储的数据空间可控则缓存工具还是很有必要的。Cache存储的是键值对的集合，不同时是还需要处理缓存过期、动态加载等算法逻辑，需要额外信息实现这些操作，对此根据面向对象的思想，还需要做方法与数据的关联性封装，主要实现的缓存功能有：自动将节点加载至缓存结构中，当缓存的数据超过最大值时，使用LRU算法替换；它具备根据节点上一次被访问或写入时间计算缓存过期机制，缓存的key被封装在WeakReference引用中，缓存的value被封装在WeakReference或SoftReference引用中；还可以统计缓存使用过程中的命中率、异常率和命中率等统计数据。</p><h3 id="构建缓存对象"><a href="#构建缓存对象" class="headerlink" title="构建缓存对象"></a>构建缓存对象</h3><p>我们先看一个示例，再来讲解使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rickiyang.learn.cache;<br><br><span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<br><span class="hljs-keyword">import</span> com.google.common.cache.CacheLoader;<br><span class="hljs-keyword">import</span> com.google.common.cache.LoadingCache;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuavaCacheService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCache</span><span class="hljs-params">()</span> </span>&#123;<br>        LoadingCache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()<br>                <span class="hljs-comment">//设置并发级别为8，并发级别是指可以同时写缓存的线程数</span><br>                .concurrencyLevel(<span class="hljs-number">8</span>)<br>                <span class="hljs-comment">//设置缓存容器的初始容量为10</span><br>                .initialCapacity(<span class="hljs-number">10</span>)<br>                <span class="hljs-comment">//设置缓存最大容量为100，超过100之后就会按照LRU最近虽少使用算法来移除缓存项</span><br>                .maximumSize(<span class="hljs-number">100</span>)<br>                <span class="hljs-comment">//是否需要统计缓存情况,该操作消耗一定的性能,生产环境应该去除</span><br>                .recordStats()<br>                <span class="hljs-comment">//设置写缓存后n秒钟过期</span><br>                .expireAfterWrite(<span class="hljs-number">60</span>, TimeUnit.SECONDS)<br>                <span class="hljs-comment">//设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite</span><br>                <span class="hljs-comment">//.expireAfterAccess(17, TimeUnit.SECONDS)</span><br>                <span class="hljs-comment">//只阻塞当前数据加载线程，其他线程返回旧值</span><br>                <span class="hljs-comment">//.refreshAfterWrite(13, TimeUnit.SECONDS)</span><br>                <span class="hljs-comment">//设置缓存的移除通知</span><br>                .removalListener(notification -&gt; &#123;<br>                    System.out.println(notification.getKey() + <span class="hljs-string">" "</span> + notification.getValue() + <span class="hljs-string">" 被移除,原因:"</span> + notification.getCause());<br>                &#125;)<br>                <span class="hljs-comment">//build方法中可以指定CacheLoader，在缓存不存在时通过CacheLoader的实现自动加载缓存</span><br>                .build(<span class="hljs-keyword">new</span> DemoCacheLoader());<br><br>        <span class="hljs-comment">//模拟线程并发</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//非线程安全的时间格式化工具</span><br>            SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"HH:mm:ss"</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    String value = cache.get(<span class="hljs-number">1</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + simpleDateFormat.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">" "</span> + value);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"HH:mm:ss"</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    String value = cache.get(<span class="hljs-number">1</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + simpleDateFormat.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">" "</span> + value);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">//缓存状态查看</span><br>        System.out.println(cache.stats().toString());<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 随机缓存加载,实际使用时应实现业务的缓存加载逻辑,例如从数据库获取数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoCacheLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CacheLoader</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">load</span><span class="hljs-params">(Integer key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 加载数据开始"</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">8</span>);<br>            Random random = <span class="hljs-keyword">new</span> Random();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 加载数据结束"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"value:"</span> + random.nextInt(<span class="hljs-number">10000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面一段代码展示了如何使用Cache创建一个缓存对象并使用它。</p><p>LoadingCache是Cache的子接口，相比较于Cache，当从LoadingCache中读取一个指定key的记录时，如果该记录不存在，则LoadingCache可以自动执行加载数据到缓存的操作。</p><p>在调用CacheBuilder的build方法时，必须传递一个CacheLoader类型的参数，CacheLoader的load方法需要我们提供实现。当调用LoadingCache的get方法时，如果缓存不存在对应key的记录，则CacheLoader中的load方法会被自动调用从外存加载数据，load方法的返回值会作为key对应的value存储到LoadingCache中，并从get方法返回。</p><p>当然如果你不想指定重建策略，那么你可以使用无参的build()方法，它将返回Cache类型的构建对象。</p><p>CacheBuilder 是Guava 提供的一个快速构建缓存对象的工具类。CacheBuilder类采用builder设计模式，它的每个方法都返回CacheBuilder本身，直到build方法被调用。 该类中提供了很多的参数设置选项，你可以设置cache的默认大小，并发数，存活时间，过期策略等等。</p><h4 id="可选配置分析"><a href="#可选配置分析" class="headerlink" title="可选配置分析"></a>可选配置分析</h4><h5 id="缓存的并发级别"><a href="#缓存的并发级别" class="headerlink" title="缓存的并发级别"></a>缓存的并发级别</h5><p>Guava提供了设置并发级别的api，使得缓存支持并发的写入和读取。同 ConcurrentHashMap 类似Guava cache的并发也是通过分离锁实现。在一般情况下，将并发级别设置为服务器cpu核心数是一个比较不错的选择。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CacheBuilder.newBuilder()<br><span class="hljs-comment">// 设置并发级别为cpu核心数</span><br>.concurrencyLevel(Runtime.getRuntime().availableProcessors()) <br>.build();<br></code></pre></td></tr></table></figure><h5 id="缓存的初始容量设置"><a href="#缓存的初始容量设置" class="headerlink" title="缓存的初始容量设置"></a>缓存的初始容量设置</h5><p>我们在构建缓存时可以为缓存设置一个合理大小初始容量，由于Guava的缓存使用了分离锁的机制，扩容的代价非常昂贵。所以合理的初始容量能够减少缓存容器的扩容次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CacheBuilder.newBuilder()<br><span class="hljs-comment">// 设置初始容量为100</span><br>.initialCapacity(<span class="hljs-number">100</span>)<br>.build();<br></code></pre></td></tr></table></figure><h5 id="设置最大存储"><a href="#设置最大存储" class="headerlink" title="设置最大存储"></a>设置最大存储</h5><p>Guava Cache可以在构建缓存对象时指定缓存所能够存储的最大记录数量。当Cache中的记录数量达到最大值后再调用put方法向其中添加对象，Guava会先从当前缓存的对象记录中选择一条删除掉，腾出空间后再将新的对象存储到Cache中。</p><ol><li><strong>基于容量的清除(size-based eviction):</strong> 通过CacheBuilder.maximumSize(long)方法可以设置Cache的最大容量数，当缓存数量达到或接近该最大值时，Cache将清除掉那些最近最少使用的缓存;</li><li>*<em>基于权重的清除: *</em> 使用CacheBuilder.weigher(Weigher)指定一个权重函数，并且用CacheBuilder.maximumWeight(long)指定最大总重。比如每一项缓存所占据的内存空间大小都不一样，可以看作它们有不同的“权重”（weights）。</li></ol><h5 id="缓存清除策略"><a href="#缓存清除策略" class="headerlink" title="缓存清除策略"></a>缓存清除策略</h5><h6 id="1-基于存活时间的清除"><a href="#1-基于存活时间的清除" class="headerlink" title="1. 基于存活时间的清除"></a>1. 基于存活时间的清除</h6><ul><li>expireAfterWrite 写缓存后多久过期</li><li>expireAfterAccess 读写缓存后多久过期</li><li>refreshAfterWrite 写入数据后多久过期,只阻塞当前数据加载线程,其他线程返回旧值</li></ul><p>这几个策略时间可以单独设置,也可以组合配置。</p><h6 id="2-上面提到的基于容量的清除"><a href="#2-上面提到的基于容量的清除" class="headerlink" title="2. 上面提到的基于容量的清除"></a>2. 上面提到的基于容量的清除</h6><h6 id="3-显式清除"><a href="#3-显式清除" class="headerlink" title="3. 显式清除"></a>3. 显式清除</h6><p>任何时候，你都可以显式地清除缓存项，而不是等到它被回收，Cache接口提供了如下API：</p><ol><li>个别清除：Cache.invalidate(key)</li><li>批量清除：Cache.invalidateAll(keys)</li><li>清除所有缓存项：Cache.invalidateAll()</li></ol><h6 id="4-基于引用的清除（Reference-based-Eviction）"><a href="#4-基于引用的清除（Reference-based-Eviction）" class="headerlink" title="4. 基于引用的清除（Reference-based Eviction）"></a>4. 基于引用的清除（Reference-based Eviction）</h6><p>在构建Cache实例过程中，通过设置使用弱引用的键、或弱引用的值、或软引用的值，从而使JVM在GC时顺带实现缓存的清除，不过一般不轻易使用这个特性。</p><ul><li>CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式，使用弱引用键的缓存用而不是equals比较键。</li><li>CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式，使用弱引用值的缓存用而不是equals比较值。</li><li>CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定（见上文，基于容量回收）。使用软引用值的缓存同样用==而不是equals比较值。</li></ul><h5 id="清理什么时候发生"><a href="#清理什么时候发生" class="headerlink" title="清理什么时候发生"></a>清理什么时候发生</h5><p>也许这个问题有点奇怪，如果设置的存活时间为一分钟，难道不是一分钟后这个key就会立即清除掉吗？我们来分析一下如果要实现这个功能，那Cache中就必须存在线程来进行周期性地检查、清除等工作，很多cache如redis、ehcache都是这样实现的。</p><p>使用CacheBuilder构建的缓存不会”自动”执行清理和回收工作，也不会在某个缓存项过期后马上清理，也没有诸如此类的清理机制。相反，它会在写操作时顺带做少量的维护工作，或者偶尔在读操作时做——如果写操作实在太少的话。</p><p>这样做的原因在于：如果要自动地持续清理缓存，就必须有一个线程，这个线程会和用户操作竞争共享锁。此外，某些环境下线程创建可能受限制，这样CacheBuilder就不可用了。参考如下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rickiyang.learn.cache;<br><br><span class="hljs-keyword">import</span> com.google.common.cache.Cache;<br><span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuavaCacheService</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">static</span> Cache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()<br>            .expireAfterWrite(<span class="hljs-number">5</span>, TimeUnit.SECONDS)<br>            .build();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"HH:mm:ss"</span>);<br>                System.out.println(sdf.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">" size: "</span> + cache.size());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"HH:mm:ss"</span>);<br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>);<br>        System.out.println(<span class="hljs-string">"写入 key:1 ,value:"</span> + cache.getIfPresent(<span class="hljs-number">1</span>));<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>);<br>        System.out.println(<span class="hljs-string">"写入 key:2 ,value:"</span> + cache.getIfPresent(<span class="hljs-number">2</span>));<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(sdf.format(<span class="hljs-keyword">new</span> Date())<br>                + <span class="hljs-string">" sleep 10s , key:1 ,value:"</span> + cache.getIfPresent(<span class="hljs-number">1</span>));<br>        System.out.println(sdf.format(<span class="hljs-keyword">new</span> Date())<br>                + <span class="hljs-string">" sleep 10s, key:2 ,value:"</span> + cache.getIfPresent(<span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br><br>部分输出结果：<br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">36</span> size: <span class="hljs-number">0</span><br>写入 key:<span class="hljs-number">1</span> ,value:a<br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">38</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">40</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">42</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">44</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">46</span> size: <span class="hljs-number">1</span><br>写入 key:<span class="hljs-number">2</span> ,value:b<br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">48</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">50</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">52</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">54</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">56</span> size: <span class="hljs-number">1</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">56</span> sleep <span class="hljs-number">10</span>s , key:<span class="hljs-number">1</span> ,value:<span class="hljs-keyword">null</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">56</span> sleep <span class="hljs-number">10</span>s, key:<span class="hljs-number">2</span> ,value:<span class="hljs-keyword">null</span><br><span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">58</span> size: <span class="hljs-number">0</span><br><span class="hljs-number">23</span>:<span class="hljs-number">58</span>:<span class="hljs-number">00</span> size: <span class="hljs-number">0</span><br><span class="hljs-number">23</span>:<span class="hljs-number">58</span>:<span class="hljs-number">02</span> size: <span class="hljs-number">0</span><br>    ...<br>    ...<br></code></pre></td></tr></table></figure><p>上面程序设置了缓存过期时间为5S，每打印一次当前的size需要2S，打印了5次size之后写入key 2，此时的size为1，说明在这个时候才把第一次应该过期的key 1给删除。</p><p><strong>给移除操作添加一个监听器：</strong></p><p>可以为Cache对象添加一个移除监听器，这样当有记录被删除时可以感知到这个事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">RemovalListener&lt;String, String&gt; listener = notification -&gt; System.out.println(<span class="hljs-string">"["</span> + notification.getKey() + <span class="hljs-string">":"</span> + notification.getValue() + <span class="hljs-string">"] is removed!"</span>);<br>        Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder()<br>                .maximumSize(<span class="hljs-number">5</span>)<br>                .removalListener(listener)<br>                .build();<br></code></pre></td></tr></table></figure><p><strong>但是要注意的是：</strong></p><p><strong>默认情况下，监听器方法是在移除缓存时同步调用的。因为缓存的维护和请求响应通常是同时进行的，代价高昂的监听器方法在同步模式下会拖慢正常的缓存请求。在这种情况下，你可以使用<code>RemovalListeners.asynchronous(RemovalListener, Executor)</code>把监听器装饰为异步操作。</strong></p><h5 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h5><p>上面我们说过使用get方法的时候如果key不存在你可以使用指定方法去加载这个key。在Cache构建的时候通过指定CacheLoder的方式。如果你没有指定，你也可以在get的时候显式的调用call方法来设置key不存在的补救策略。</p><p>Cache的get方法有两个参数，第一个参数是要从Cache中获取记录的key，第二个记录是一个Callable对象。</p><p>当缓存中已经存在key对应的记录时，get方法直接返回key对应的记录。如果缓存中不包含key对应的记录，Guava会启动一个线程执行Callable对象中的call方法，call方法的返回值会作为key对应的值被存储到缓存中，并且被get方法返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rickiyang.learn.cache;<br><br><span class="hljs-keyword">import</span> com.google.common.cache.Cache;<br><span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuavaCacheService</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">3</span>)<br>            .build();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">"thread1"</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                String value = cache.get(<span class="hljs-string">"key"</span>, <span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        System.out.println(<span class="hljs-string">"thread1"</span>); <span class="hljs-comment">//加载数据线程执行标志</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//模拟加载时间</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">"thread1"</span>;<br>                    &#125;<br>                &#125;);<br>                System.out.println(<span class="hljs-string">"thread1 "</span> + value);<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">"thread2"</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                String value = cache.get(<span class="hljs-string">"key"</span>, <span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        System.out.println(<span class="hljs-string">"thread2"</span>); <span class="hljs-comment">//加载数据线程执行标志</span><br>                        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//模拟加载时间</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">"thread2"</span>;<br>                    &#125;<br>                &#125;);<br>                System.out.println(<span class="hljs-string">"thread2 "</span> + value);<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>&#125;<br><br>输出结果为：<br>thread1<br>thread2<br>thread2<br>thread1 thread2<br>thread2 thread2<br></code></pre></td></tr></table></figure><p>可以看到输出结果：两个线程都启动，输出thread1，thread2，接着又输出了thread2，说明进入了thread2的call方法了，此时thread1正在阻塞，等待key被设置。然后thread1 得到了value是thread2，thread2的结果自然也是thread2。</p><p>这段代码中有两个线程共享同一个Cache对象，两个线程同时调用get方法获取同一个key对应的记录。由于key对应的记录不存在，所以两个线程都在get方法处阻塞。此处在call方法中调用Thread.sleep(1000)模拟程序从外存加载数据的时间消耗。</p><p>从结果中可以看出，虽然是两个线程同时调用get方法，但只有一个get方法中的Callable会被执行(没有打印出load2)。Guava可以保证当有多个线程同时访问Cache中的一个key时，如果key对应的记录不存在，Guava只会启动一个线程执行get方法中Callable参数对应的任务加载数据存到缓存。当加载完数据后，任何线程中的get方法都会获取到key对应的值。</p><h5 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h5><p>可以对Cache的命中率、加载数据时间等信息进行统计。在构建Cache对象时，可以通过CacheBuilder的recordStats方法开启统计信息的开关。开关开启后Cache会自动对缓存的各种操作进行统计，调用Cache的stats方法可以查看统计后的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rickiyang.learn.cache;<br><br><span class="hljs-keyword">import</span> com.google.common.cache.Cache;<br><span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuavaCacheService</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()<br>                .maximumSize(<span class="hljs-number">3</span>)<br>                .recordStats() <span class="hljs-comment">//开启统计信息开关</span><br>                .build();<br>        cache.put(<span class="hljs-string">"1"</span>, <span class="hljs-string">"v1"</span>);<br>        cache.put(<span class="hljs-string">"2"</span>, <span class="hljs-string">"v2"</span>);<br>        cache.put(<span class="hljs-string">"3"</span>, <span class="hljs-string">"v3"</span>);<br>        cache.put(<span class="hljs-string">"4"</span>, <span class="hljs-string">"v4"</span>);<br><br>        cache.getIfPresent(<span class="hljs-string">"1"</span>);<br>        cache.getIfPresent(<span class="hljs-string">"2"</span>);<br>        cache.getIfPresent(<span class="hljs-string">"3"</span>);<br>        cache.getIfPresent(<span class="hljs-string">"4"</span>);<br>        cache.getIfPresent(<span class="hljs-string">"5"</span>);<br>        cache.getIfPresent(<span class="hljs-string">"6"</span>);<br><br>        System.out.println(cache.stats()); <span class="hljs-comment">//获取统计信息</span><br>    &#125;<br><br>&#125;<br><br>输出：<br>CacheStats&#123;hitCount=<span class="hljs-number">3</span>, missCount=<span class="hljs-number">3</span>, loadSuccessCount=<span class="hljs-number">0</span>, loadExceptionCount=<span class="hljs-number">0</span>, totalLoadTime=<span class="hljs-number">0</span>, evictionCount=<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;缓存分为本地缓存和远端缓存。常见的远端缓存有Redis，MongoDB；本地缓存一般使用map的方式保存在本地内存中。一般我们在业务中操作缓
      
    
    </summary>
    
    
    
      <category term="guaua cache" scheme="https://blacktomm.github.io/tags/guaua-cache/"/>
    
  </entry>
  
  <entry>
    <title>spring-ioc-step-01</title>
    <link href="https://blacktomm.github.io/2021/09/01/spring-ioc-step-01/"/>
    <id>https://blacktomm.github.io/2021/09/01/spring-ioc-step-01/</id>
    <published>2021-08-31T17:14:58.000Z</published>
    <updated>2021-09-09T17:28:57.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>从懵懵懂懂翻开<a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring实战 第四版》</a>的那一刻起，就逐渐开始与后端结缘，奈何配置文件繁杂，一度感觉疲惫，甚至有些怀疑，发展了十几年的框架实际用的并不得心应手？直到开始使用SpringBoot, 约定优于配置，的确简化了许多不必要的文件，就像maven的发展历程一样。一转眼，Spring框架已经发展到了5.3.9，但看十年前的书籍，却依然适用，从一开始，开发者就确定了其基本骨架。随着使用的时间的越长，却越来越迷茫，刚好看到个<a href="https://github.com/fuzhengwei/small-spring" target="_blank" rel="noopener">small-spring</a>项目，一步步搭建的过程开始对整个框架多了一丝理解。</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Spring框架比较熟悉的两个特性就是控制反转（IOC）与切面(AOP),控制反转是通过将对象的创建、对象的存储、对象的管理交给了Spring容器，从而将创建与使用解耦，减少了同一个类多个实例的创建，当重复的代码越少，维护出错的可能性就越低。切面则是在实例创建的过程中实现的代理，整体功能依旧以底层容器为依托，但框架的设计、解耦从来都不是件简单的事，保持多年稳定更是难上加难。经过多年的发展，Spring的代码已经相当复杂，对于代码实践较少的小白来说，debug也依旧是雾里看花，难窥奥妙，好在有人指路，少了些磕磕绊绊，就写点自己的理解吧。</p><p><img src="https://docs.spring.io/spring-framework/docs/4.3.20.RELEASE/spring-framework-reference/html/images/spring-overview.png" alt="spring overview"></p><p><a href="https://docs.spring.io/spring-framework/docs/4.3.20.RELEASE/spring-framework-reference/html/overview.html" target="_blank" rel="noopener">Spring框架一览</a></p><h3 id="Spring容器究竟是什么？"><a href="#Spring容器究竟是什么？" class="headerlink" title="Spring容器究竟是什么？"></a>Spring容器究竟是什么？</h3><p><strong>原来它只是个Map</strong>，想起编写最基本的类的时候，在一个类中创建字段，赋值的过程就像是一组组键值对。对于一个Map来说，同样可以根据实例名称来获取实例对象，getBean也只是个查询操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    BeanFactory factory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"basic_dl/quickstart-byname.xml"</span>);<br>    Person person = (Person) factory.getBean(<span class="hljs-string">"person"</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个简单的对象实例被IOC 容器创建后，下次获取时只需要简单的获取就可以，对于顶层的接口，通常只提供get方法，从而能够有效提升其扩展性。初始时只考虑单例 bean的情况，BeanFactory作为顶层获取 Bean的接口，之所以还会有SingletonBeanRegistry, 一方面是考虑到后续还有非单例情形，另一方面尽量与现有框架一致，其默认实现DefaultSingletonBeanRegistry 内部增加了 HashMap 作为 单例Bean 容器。</p><p><img src="https://blog-field-1258773891.cos.ap-beijing.myqcloud.com/record/2021%20/09/%2007/DefaultListableBeanFactory.png" alt="DefaultListableBeanFactory"></p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.config;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Class beanClass;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanDefinition</span><span class="hljs-params">(Class beanClass)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.beanClass = beanClass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getBeanClass</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> beanClass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClass</span><span class="hljs-params">(Class beanClass)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.beanClass = beanClass;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BeanDefinition 包含待传递的实例类，在初始化阶段会进行调用。</p><h4 id="Beanfactory"><a href="#Beanfactory" class="headerlink" title="Beanfactory"></a>Beanfactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Beanfactory对外只提供一个获取 Bean 的接口，至于 bean的注入则是由容器来处理的，通常包括 xml 的解析与注解注入实现。</p><h4 id="SingletonBeanRegistry"><a href="#SingletonBeanRegistry" class="headerlink" title="SingletonBeanRegistry"></a>SingletonBeanRegistry</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.config;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SingletonBeanRegistry</span> </span>&#123;<br><span class="hljs-function">Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DefaultSingletonBeanRegistry"><a href="#DefaultSingletonBeanRegistry" class="headerlink" title="DefaultSingletonBeanRegistry"></a>DefaultSingletonBeanRegistry</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.support;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSingletonBeanRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SingletonBeanRegistry</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br><span class="hljs-keyword">return</span> singletonObjects.get(beanName);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;<br>singletonObjects.put(beanName, singletonObject);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例 Bean 的保存由singletonObjects由 Map 来实现，对于 bean 的获取通常借助于 BeanFactory 实现类，在获取时可对单例与非单例情况进行处理。</p><h4 id="AbstractBeanFactory"><a href="#AbstractBeanFactory" class="headerlink" title="AbstractBeanFactory"></a>AbstractBeanFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.support;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultSingletonBeanRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>Object bean = getSingleton(name);<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br>BeanDefinition beanDefinition = getBeanDefinition(name);<br><span class="hljs-keyword">return</span> createBean(name, beanDefinition);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractBeanFactory主要是对 getBean方法的实现，当获取 Bean 时，优先从单例 Map中查找，当查找不到时，则需要获取 BeanDefinition并注入，其实现交由子类负责。</p><h4 id="AbstractAutowireCapableBeanFactory"><a href="#AbstractAutowireCapableBeanFactory" class="headerlink" title="AbstractAutowireCapableBeanFactory"></a>AbstractAutowireCapableBeanFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.support;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactory</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>Object bean = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>bean = beanDefinition.getBeanClass().newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>addSingleton(beanName,bean);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 createBean注入的过程依赖于 BeanDefinition 传入的类名，而后通过反射实现实例的创建，由于单例 Map中不包含该对象，因此需要添加到其中，避免 getBean中再次获取不到而导致重复创建。</p><h4 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.support;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans.factory.support;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutowireCapableBeanFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;<br>      beanDefinitionMap.put(beanName, beanDefinition);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>      BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);<br>      <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeansException(<span class="hljs-string">"No bean named '"</span> + beanName + <span class="hljs-string">"' is defined"</span>);<br>      <span class="hljs-keyword">return</span> beanDefinition;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会将注入的 Bean放入beanDefinitionMap中，作为一层缓存，当单例 Bean 中 Map查找不到时，会通过getBeanDefinition获取 BeanDefinition，并注入单例 Bean 中 Map，相当于 BeanFactory只负责获取，而 BeanDefinition 的注册交由BeanDefinitionRegistry。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>随便自定义一个测试类，如</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework.beans;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryUserInfo</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">"查询用户信息"</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code.springframework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiTest</span> </span>&#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_BeanFactory</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 1.初始化 BeanFactory</span><br>DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br><br><span class="hljs-comment">// 2.注册 bean</span><br>BeanDefinition beanDefinition = <span class="hljs-keyword">new</span> BeanDefinition(UserService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>beanFactory.registerBeanDefinition(<span class="hljs-string">"userService"</span>, beanDefinition);<br><br><span class="hljs-comment">// 3.第一次获取 bean</span><br>UserService userService = (UserService) beanFactory.getBean(<span class="hljs-string">"userService"</span>);<br>userService.queryUserInfo();<br>System.out.println(<span class="hljs-string">"第一次获取："</span> + userService);<br><br><span class="hljs-comment">// 4.第二次获取 bean from Singleton</span><br>UserService userService_singleton = (UserService) beanFactory.getBean(<span class="hljs-string">"userService"</span>);<br>userService_singleton.queryUserInfo();<br>System.out.println(<span class="hljs-string">"第二次获取："</span> + userService);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>初始时单例 Bean 中 Map不包含该实例，需要获取 BeanDefinition并注入，因此先注册 BeanDefition，而后调用 getBean 来触发 Bean 注入到 Map 中，debug 可以看到多次获取为同一对象。</p><p>参考：</p><ul><li><a href="https://github.com/fuzhengwei/small-spring" target="_blank" rel="noopener">Spring 手撸专栏</a></li><li><a href="https://juejin.cn/book/6857911863016390663/section" target="_blank" rel="noopener">从 0 开始深入学习 Spring</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h3&gt;&lt;p&gt;从懵懵懂懂翻开&lt;a href=&quot;https://book.douban.com/subject/26767354/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="spring" scheme="https://blacktomm.github.io/categories/spring/"/>
    
    
      <category term="spring-ioc" scheme="https://blacktomm.github.io/tags/spring-ioc/"/>
    
  </entry>
  
  <entry>
    <title>手把手搭个操作系统（一）</title>
    <link href="https://blacktomm.github.io/2021/08/19/operating-system-step-01/"/>
    <id>https://blacktomm.github.io/2021/08/19/operating-system-step-01/</id>
    <published>2021-08-19T14:58:18.000Z</published>
    <updated>2021-08-19T15:41:36.612Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是操作系统实战的第一篇，主要讲述如何利用 bochs 创建启动盘。</p><h2 id="配置Bochs"><a href="#配置Bochs" class="headerlink" title="配置Bochs"></a>配置Bochs</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>Bochs 需要在 X11 环境下运行，因此你的 Linux 系统必须已经安装了X Window 系统才能使用Bochs。 因为 Bochs 是用C++写的，所以这里要安装GNU gcc/g++编译器。<br> 安装命令如下：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">sudo apt-<span class="hljs-keyword">get</span> install build-essential <br>sudo apt-<span class="hljs-keyword">get</span> install xorg-dev <br>sudo apt-<span class="hljs-keyword">get</span> install bison <br>sudo apt-<span class="hljs-keyword">get</span> install g++<br></code></pre></td></tr></table></figure><p>别忘了安装<code>bochs-x</code></p><h3 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h3><ul><li><p>去<a href="https://sourceforge.net/projects/bochs/files/" target="_blank" rel="noopener">官网</a>下载 bochs-2.6.11.tar.gz</p></li><li><p>解压缩 tar -vxzf bochs-2.6.11.tar.gz并进入解压目录bochs-2.6.11</p></li><li><p>配置boch，在bochs-2.6.11目录下执行</p>  <figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">./configure --prefix=/home/onedy/Public/software/bochs/bochs-pre --enable-debugger --enable-disasm --enable-iodebug --enable-iodebug --enable-x86-debugger --with-x --with-x11 libs='-lx11'<br><br>如果出现错误，根据提示修改，如<br><span class="hljs-keyword">ERROR: </span>pkg-config was not found, or unable to access the gtk+<span class="hljs-string">-2</span>.0 package.<br>Install pkg-config and the gtk+ development package,<br>or disable the gui debugger, or the wxWidgets display library (whichever is being used).<br><br>说明需要安装gtk+<span class="hljs-string">-2</span>.0<br>sudo apt-get install gtk2.0<br>参考自 https://askubuntu.com/questions/765526/how-to-install-gtk2<span class="hljs-string">-0</span><br></code></pre></td></tr></table></figure><p>  注意各行结尾的’&#39;字符前面有个空格。下面简要说明一下configure 的参数。</p>  <figure class="highlight haml"><table><tr><td class="code"><pre><code class="hljs haml">-<span class="ruby">-prefix=<span class="hljs-regexp">/your_path/bochs</span> 是用来指定bochs 的安装目录，根据个人实际情况将your_path 替换为自己待安装的路径。</span><br><span class="ruby">--enable-debugger 打开bochs 自己的调试器。</span><br><span class="ruby">--enable-disasm 使bochs 支持反汇编。</span><br><span class="ruby">--enable-iodebug 启用io 接口调试器。</span><br><span class="ruby">--enable-x86-debugger 支持x86 调试器。</span><br><span class="ruby">--with-x 使用x windows。</span><br><span class="ruby">--with-x11 使用x11 图形用户接口。</span><br></code></pre></td></tr></table></figure><p>  上面的编译参数是不支持gdb 远程调试的，如果想用gdb 调试，就要将参数–enable-debugger 替换为<br>  –enable-gdb-stub。<br>  –enable-gdb-stub 用来打开对gdb 的支持，这样我们就可以用gdb 来远程调试了。<br>  不过，需要注意的是不能同时打开这两个开关，否则bochs 会报错，即configure：error：–enable-debugger and –enable-gdb-stub are mutually exclusive。<br>  也就是说，bochs 本身是支持调试的，要么用本身的调试功能，要么用gdb 的调试功能，鱼和熊掌在一台模拟器上不可兼得。</p></li></ul><ul><li><p>正确运行后，会产生一个Makefile文件，然后 sudo make，如果执行不成功，需要排查后做make clean，再执行sudo make</p></li><li><p>安装 sudo make install，就会在指定的bochs 安装目录下（如/home/onedy/Public/software/bochs/bochs-pre）生成对应文件</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装好bochs之后我们要对它进行配置，这个配置大家可以参考安装目录下的bochsrc-sample.txt，该文件的路径在bochs安装目录下的share/doc/bochs/bochsrc-sample.txt，部分代码如下</p><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">###############################################<br># Configuration file for Bochs<br>###############################################<br><br><span class="hljs-number">1.5</span> 运行bochs<br><span class="hljs-number">49</span><br># 第一步，首先设置Bochs 在运行过程中能够使用的内存，本例为<span class="hljs-number">32</span>MB。<br># 关键字为：megs<br>megs:<span class="hljs-number">32</span><br><br># 第二步，设置对应真实机器的BIOS 和VGA BIOS。<br># 对应两个关键字为：romimage 和 vgaromimage<br>romimage: file=/实际路径/bochs/share/bochs/BIOS-bochs-latest<br>vgaromimage: file=/实际路径/bochs/share/bochs/VGABIOS-lgpl-latest<br><br># 第三步，设置Bochs 所使用的磁盘，软盘的关键字为floppy。<br># 若只有一个软盘，则使用floppya 即可，若有多个，则为floppya，floppyb…<br>#floppya: <span class="hljs-number">1</span>_44=a.img, status=inserted<br><br># 第四步，选择启动盘符。<br>#boot: floppy #默认从软盘启动，将其注释<br>boot: disk #改为从硬盘启动。我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作。<br><br># 第五步，设置日志文件的输出。<br>log: bochs.out<br><br># 第六步，开启或关闭某些功能。<br># 下面是关闭鼠标，并打开键盘。<br>mouse: enabled=<span class="hljs-number">0</span><br>keyboard_mapping: enabled=<span class="hljs-number">1</span>,<br>map=/实际路径/bochs/share/bochs/keymaps/x11-pc-us.map<br><br># 硬盘设置<br>ata0: enabled=<span class="hljs-number">1</span>, ioaddr1=<span class="hljs-number">0x1f0</span>, ioaddr2=<span class="hljs-number">0x3f0</span>, irq=<span class="hljs-number">14</span><br><br># 下面的是增加的bochs 对gdb 的支持，这样gdb 便可以远程连接到此机器的<span class="hljs-number">1234</span> 端口调试了<br>gdbstub: enabled=<span class="hljs-number">1</span>, port=<span class="hljs-number">1234</span>, text_base=<span class="hljs-number">0</span>, data_base=<span class="hljs-number">0</span>, bss_base=<span class="hljs-number">0</span><br>################### 配置文件结束 #####################<br></code></pre></td></tr></table></figure><p>好了，现在将上面的配置文件存为<strong>bochsrc.disk 放在bochs 安装目录</strong>下。（bochs 配置文件位置不固定，<br>名字也不要求固定），后缀.disk 是我人为加的，为了表示此配置文件配置的内容是从硬盘启动，这样较明确。</p><p>个人配置文件 bochsrc.disk 如下，放置于bochs安装目录下</p><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#首先设置 Bochs 在运行过程中能够使用的内存，本例为 32MB。</span><br><span class="hljs-meta">#关键字为 megs</span><br><span class="hljs-symbol">megs:</span><span class="hljs-number">32</span><br><br><span class="hljs-meta">#设置对应真实机器的 BIOS 和 VGA BIOS 。</span><br><span class="hljs-meta">#对应两个关键字为 ： romimage 和 vgaromimage</span><br><span class="hljs-meta">#romimage:file=安装目录/share/bochs/BIOS-bochs-latest</span><br><span class="hljs-symbol">romimage:</span>file=<span class="hljs-meta-keyword">/home/</span>onedy/Public<span class="hljs-meta-keyword">/software/</span>bochs<span class="hljs-meta-keyword">/bochs-pre/</span>share<span class="hljs-meta-keyword">/bochs/</span>BIOS-bochs-latest<br><span class="hljs-symbol">vgaromimage:</span>file=<span class="hljs-meta-keyword">/home/</span>onedy/Public<span class="hljs-meta-keyword">/software/</span>bochs<span class="hljs-meta-keyword">/bochs-pre/</span>share<span class="hljs-meta-keyword">/bochs/</span>VGABIOS-lgpl-latest <br><br><span class="hljs-meta">#选择启动盘符</span><br><span class="hljs-symbol">boot:</span>disk  <span class="hljs-meta">#从硬盘启动</span><br><br><span class="hljs-meta"># 设置日志文件的输入位置</span><br><span class="hljs-meta">#log:bochs.out</span><br><span class="hljs-symbol">log:</span>bochsout.txt <br><br><span class="hljs-meta"># 关闭鼠标，打开键盘</span><br><span class="hljs-symbol">mouse:</span>enabled=<span class="hljs-number">0</span><br><span class="hljs-symbol">keyboard:</span>keymap=<span class="hljs-meta-keyword">/home/</span>onedy/Public<span class="hljs-meta-keyword">/software/</span>bochs<span class="hljs-meta-keyword">/bochs-pre/</span>share<span class="hljs-meta-keyword">/bochs/</span>keymaps/x11-pc-us.map<br><br><span class="hljs-meta"># 设置硬盘</span><br><span class="hljs-symbol">ata0:</span>enabled=<span class="hljs-number">1</span>,ioaddr1=<span class="hljs-number">0x1f0</span>,ioaddr2=<span class="hljs-number">0x3f0</span>,irq=<span class="hljs-number">14</span><br><span class="hljs-meta"># 启动盘信息，需要先创建</span><br>ata0-master:type=disk,path=<span class="hljs-string">"hd60M.img"</span>, mode=flat,cylinders=<span class="hljs-number">121</span>,heads=<span class="hljs-number">16</span>,spt=<span class="hljs-number">63</span><br></code></pre></td></tr></table></figure><p><strong>注意中英文标点差异，键值对冒号不可省略，注释#号为英文字符</strong></p><h4 id="创建启动盘"><a href="#创建启动盘" class="headerlink" title="创建启动盘"></a>创建启动盘</h4><p>在安装目录下执行</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">onedy<span class="hljs-variable">@onedy</span><span class="hljs-symbol">:~/Public/software/bochs/bochs-pre</span><span class="hljs-variable">$ </span>bin/bximage<br></code></pre></td></tr></table></figure><p>除指定硬盘大小外，其他选择默认即可</p><p><img src="https://pic1.zhimg.com/80/v2-eb962cd79784c2c55fb75ac21263bbdc_720w.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-176cc91883d40826aef180e3a7096097_720w.jpg" alt=""></p><p>60代表该硬盘的大小为60M，hd60M.img是我给改硬盘取得名字，最后一行用绿色标记的是我们需要加入到配置文件中的，这是我们硬盘配置好之后，bochs给我们自动生成的硬盘信息，接下来在配置文件的最后一行加上该硬盘的信息，上面已加入配置文件信息。</p><h4 id="启动Bochs"><a href="#启动Bochs" class="headerlink" title="启动Bochs"></a>启动Bochs</h4><p>hd60M.img与配置文件均放在安装目录下/home/onedy/Public/software/bochs/bochs-pre，因为需要读取当前文件夹内容进行启动，具体如下</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">onedy<span class="hljs-variable">@onedy</span><span class="hljs-symbol">:~/Public/software/bochs/bochs-pre</span><span class="hljs-variable">$ </span>bin/bochs -f bochsrc.disk<br></code></pre></td></tr></table></figure><p>然后选择启动模拟器</p><p><img src="https://pic2.zhimg.com/80/v2-8123759ab91d8e6b8d2f6e846e9703d9_720w.jpg" alt=""></p><p>由于开启了调试模式，会显示模拟器黑框，在<strong>控制台输入c</strong>，enter后会显示如下界面</p><p><img src="https://pic2.zhimg.com/80/v2-d2ce4d4cc2b311e8464d78927cc33559_720w.jpg" alt=""></p><p>如果嫌每次启动必须进入bochs文件下，输入这么多字麻烦，可以直接用别名来代替</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~<br>vim .bashrc<br>alias bochs='/home/onedy/Public/software/bochs/bochs-pre/bin/bochs -f /home/onedy/Public/software/bochs/bochs-pre/bochsrc.disk'<br>source .bashrc<br></code></pre></td></tr></table></figure><h4 id="Bochs调试"><a href="#Bochs调试" class="headerlink" title="Bochs调试"></a>Bochs调试</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">打开bochsdbg 启动调试<br>启动后 会在命令行窗口看到 jmpf <span class="hljs-number">0xf000</span>:e05b 说明准备跳转到bios中,还未执行 显示的指令是下一条执行的指令<br>为何物理地址是<span class="hljs-number">0x0000ffffff0</span>?因为当前boch的地址线是32根,然后bochs用64位宽度来表示,现代处理器启动时会把cs的内容设为0xF000,ip的内容设为0xfff0,<br>而且会把其余的高位部分的地址线拉高,因为人们想把bios放在内存的高地址<br>s:单步执行<br><span class="hljs-string">b:</span>设置断点 <span class="hljs-string">"b 0x7c00"</span>意思是处理器执行到地址<span class="hljs-string">"0x7c00"</span>的地方前停下来 再按c<br><span class="hljs-string">c:</span>继续执行<br><span class="hljs-string">r:</span>显示寄存器内容<br><span class="hljs-string">xp:</span>显示显存中的内容<br><span class="hljs-string">q:</span>退出<br><span class="hljs-string">n:</span>自动完成程序中循环 但是对条件转移命令无效(jns等)<br><span class="hljs-string">u:</span>反汇编 可用于越过jns等<br>info <span class="hljs-string">eflags:</span>显示标志寄存器 如果标志名称是小写的,那么该标记为<span class="hljs-number">0</span>,否则为<span class="hljs-number">1</span><br>print-stack x 可以查看当前的栈 x代表显示的数据 如果不使用参数 默认显示前<span class="hljs-number">16</span>个字<br></code></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li>操作系统真相还原 第1章</li><li><a href="https://zhuanlan.zhihu.com/p/35437842" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35437842</a> 配置文件有点小问题</li><li><a href="https://copyright1999.github.io/2020/03/23/Ubuntu18.10%E5%AE%89%E8%A3%85bochs/" target="_blank" rel="noopener">Ubuntu18.10安装bochs</a></li><li>[Ubuntu下Bochs安装与调试配置](</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇是操作系统实战的第一篇，主要讲述如何利用 bochs 创建启动盘。&lt;/p&gt;
&lt;h2 id=&quot;配置Bochs&quot;&gt;&lt;a href=&quot;#配置Bochs&quot; class=&quot;headerlink&quot; title=&quot;配置Bochs&quot;&gt;&lt;/a&gt;配置Bochs&lt;/h2&gt;&lt;h3 id=&quot;前期
      
    
    </summary>
    
    
    
      <category term="programming" scheme="https://blacktomm.github.io/tags/programming/"/>
    
      <category term="operating system" scheme="https://blacktomm.github.io/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>huxblog配置优化</title>
    <link href="https://blacktomm.github.io/2020/07/29/huxblog-optimization/"/>
    <id>https://blacktomm.github.io/2020/07/29/huxblog-optimization/</id>
    <published>2020-07-29T06:50:10.000Z</published>
    <updated>2020-07-29T12:23:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了基于HuxBlog所做的一些优化，主要涉及到：</p><ul><li><p>允许博客文章页首图及侧边栏头像链接设置为CDN</p></li><li><p>添加Gitalk评论脚本</p></li><li><p>隐藏底部社交账号头像配置</p></li></ul><h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><p>在命令行中通过 npm 来安装 Hexo：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><code>-g</code> 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。</p><p>Hexo 依赖于 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a> 和 <a href="https://git-scm.com/download/" target="_blank" rel="noopener">git</a>，在安装 Hexo 之前需要先确保已安装了这两项应用。</p><p>新建博客目录，然后在该路径下执行初始化命令：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo init<br></code></pre></td></tr></table></figure><p>执行完毕后，将会生成以下文件结构：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">.<br>├── node_modules       <span class="hljs-comment">//依赖安装目录</span><br>├── scaffolds          <span class="hljs-comment">//模板文件夹，新建的文章将会从此目录下的文件中继承格式</span><br>|   ├── draft.md         <span class="hljs-comment">//草稿模板</span><br>|   ├── page.md          <span class="hljs-comment">//页面模板</span><br>|   └── post.md          <span class="hljs-comment">//文章模板</span><br>├── <span class="hljs-keyword">source</span>             <span class="hljs-comment">//资源文件夹，用于放置图片、数据、文章等资源</span><br>|   └── _posts           <span class="hljs-comment">//文章目录</span><br>├── themes             <span class="hljs-comment">//主题文件夹</span><br>|   └── landscape        <span class="hljs-comment">//默认主题</span><br>├── .gitignore         <span class="hljs-comment">//指定不纳入git版本控制的文件</span><br>├── _config.yml        <span class="hljs-comment">//站点配置文件</span><br>├── db.json            <br>├── <span class="hljs-keyword">package</span>.json<br>└── <span class="hljs-keyword">package</span>-lock.json<br></code></pre></td></tr></table></figure><p>可以看到 themes 文件夹下已经有一个名为 landscape 的文件夹了，这是默认主题。</p><p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>该命令将会调用 Markdown 引擎解析项目中的博客内容生成网页资源，资源将会存于内存中，所以用户执行完命令之后在项目文件夹中是找不到相关的 Web 资源目录的。该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 <code>localhost:4000</code> 访问博客。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p><a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">HuxBlog</a>最初由黄玄在Jekyll搭建而成，比较简洁，目前Hexo版本主要由<a href="https://github.com/Kaijun/hexo-theme-huxblog" target="_blank" rel="noopener">Kaijun Chen</a>在维护，并做了不少优化，整体主题代码量相对Next等常见主题要小很多，便于更改。</p><p><img src="https://blog-field-1258773891.cos.ap-beijing.myqcloud.com/my-blog/2020/07/29/huxblog.png" alt=""></p><p>点击Code下载对应zip文件并将 themes 文件夹下huxblog复制到上述  Hexo 对应的 themes 文件夹下, 也可以通过<code>git clone</code>进行下载。打开站点配置文件_config.yml，将 theme 字段的值修改为 huxblog</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">huxblog</span><br></code></pre></td></tr></table></figure><p>重启服务器并刷新可使主题生效，如果重启服务器仍无效，尝试使用 <code>hexo clean</code> 清除缓存。</p><h2 id="站点优化"><a href="#站点优化" class="headerlink" title="站点优化"></a>站点优化</h2><p>由于Kaijun Chen已经给出了自己的站点配置文件<a href="https://github.com/Kaijun/hexo-theme-huxblog/blob/master/_config.yml" target="_blank" rel="noopener">_config.yml</a>，可以作为参照。如果需要优化，则要了解Huxblog主题目录：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">│  LICENSE<br>│  README.md<br>│  _config.yml<br>│<br>├─languages_to_be_added<br>├─layout<br>│  │  <span class="hljs-number">404</span>.ejs<br>│  │  about.ejs<br>│  │  archive.ejs<br>│  │  archives.ejs<br>│  │  index<span class="hljs-selector-class">.ejs</span><span class="hljs-comment">//主页</span><br>│  │  keynote.ejs<br>│  │  layout.ejs<br>│  │  page<span class="hljs-selector-class">.ejs</span><span class="hljs-comment">//文章页面</span><br>│  │  post.ejs<br>│  │  tags.ejs<br>│  │<br>│  └─_partial<br>│          <span class="hljs-selector-tag">footer</span>.ejs<br>│          head.ejs<br>│          <span class="hljs-selector-tag">nav</span>.ejs<br>│          pagination.ejs<br>│<br>└─source<br>    ├─css<br>    ├─fonts<br>    └─js<br></code></pre></td></tr></table></figure><p>根据上述目录，可对对应文件源码进行修改。</p><h3 id="文章页首图及侧边栏头像链接CDN设置"><a href="#文章页首图及侧边栏头像链接CDN设置" class="headerlink" title="文章页首图及侧边栏头像链接CDN设置"></a>文章页首图及侧边栏头像链接CDN设置</h3><p>由于GitHub服务器设在国外，国内也没有对应的CDN, 导致站点图片加载比较缓慢，影响体验，所以针对该主题做了部分优化，便于使用个人图床链接加载图片。个人文章页首图需要在markdown文件头部设置<code>header-img</code>图片链接进行设置，默认只允许添加<code>source/img</code>等文件夹下图片，添加链接则无法访问。</p><p>由 page.ejs 内源码可以看出这主要是因为在图片链接<code>page[&quot;header-img&quot;]</code>前添加了博客URL链接<code>&lt;%= config.root %&gt;</code>导致图片地址解析异常。如果要使用链接，则需要删除页面下图片URL对应的<code>&lt;%= config.root %&gt;</code>代码；如果不设置文章页 <code>header-img</code>则默认访问网站首页下的<code>header-img</code>,也就是站点配置文件<a href="https://github.com/Kaijun/hexo-theme-huxblog/blob/master/_config.yml" target="_blank" rel="noopener">_config.yml</a>中对应的图片链接，其他页面处理方法类似。</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Page</span> <span class="hljs-string">Header</span>  <span class="hljs-string">博客文章页面图片url--&gt;</span><br><span class="hljs-string">&lt;header</span> <span class="hljs-string">class="intro-header"</span> <span class="hljs-string">style="background-image:</span> <span class="hljs-string">url('&lt;%=</span> <span class="hljs-string">config.root</span> <span class="hljs-string">%&gt;&lt;%=</span> <span class="hljs-string">page["header-img"]</span> <span class="hljs-string">||</span> <span class="hljs-string">config["header-img"]</span> <span class="hljs-string">%&gt;')"&gt;</span><br>    <span class="hljs-string">&lt;div</span> <span class="hljs-string">class="container"&gt;</span><br>        <span class="hljs-string">&lt;div</span> <span class="hljs-string">class="row"&gt;</span><br>            <span class="hljs-string">&lt;div</span> <span class="hljs-string">class="col-lg-8</span> <span class="hljs-string">col-lg-offset-2</span> <span class="hljs-string">col-md-10</span> <span class="hljs-string">col-md-offset-1</span> <span class="hljs-string">"&gt;</span><br><span class="hljs-string">                &lt;div class="</span><span class="hljs-string">site-heading"&gt;</span><br>                    <span class="hljs-string">&lt;h1&gt;&lt;%=</span> <span class="hljs-string">page.title</span> <span class="hljs-string">||</span> <span class="hljs-string">config.title</span> <span class="hljs-string">%&gt;&lt;/h1&gt;</span><br>                    <span class="hljs-string">&lt;!--&lt;hr</span> <span class="hljs-string">class="small"&gt;--&gt;</span><br>                    <span class="hljs-string">&lt;span</span> <span class="hljs-string">class="subheading"&gt;&lt;%=</span> <span class="hljs-string">page.description</span> <span class="hljs-string">||</span> <span class="hljs-string">config.subtitle</span> <span class="hljs-string">||</span> <span class="hljs-string">""</span> <span class="hljs-string">%&gt;&lt;/span&gt;</span><br>                <span class="hljs-string">&lt;/div&gt;</span><br>            <span class="hljs-string">&lt;/div&gt;</span><br>        <span class="hljs-string">&lt;/div&gt;</span><br>    <span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&lt;/header&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加Gitalk评论脚本"><a href="#添加Gitalk评论脚本" class="headerlink" title="添加Gitalk评论脚本"></a>添加Gitalk评论脚本</h3><p>Gitalk和Gitment通常用来作为评论脚本，由于Gitment作者已经很久未维护过，所以选择了Gitalk, 毕竟随着时间的改变，难免会出现不兼容的问题。该主题目前提供了多说与disqus评论,也可以作为个人选择。以下就如何在文章页面添加Gitalk进行说明，需要对page.ejs源码进行修改，主要是设置div并使用Js进行渲染。</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs ejs">&lt;!-- 如果开启评论功能 --&gt;<br>&lt;% if(page.comments) &#123; %&gt;<br>        &lt;hr&gt;<br>        &lt;!-- 包含多说评论框，此处省略 --&gt;<br>        <br>        &lt;!-- disqus 评论框  --&gt;<br>        &lt;% if(config[&#39;disqus_username&#39;]) &#123; %&gt;<br>                   &lt;!-- disqus 评论框 start --&gt;<br>                   &lt;div class&#x3D;&quot;comment&quot;&gt;<br>                       &lt;div id&#x3D;&quot;disqus_thread&quot; class&#x3D;&quot;disqus-thread&quot;&gt;&lt;&#x2F;div&gt;<br>                   &lt;&#x2F;div&gt;<br>                   &lt;!-- disqus 评论框 end --&gt;<br>                   &lt;% &#125; %&gt;<br>         <br>        &lt;!-- disqus下方添加id&#x3D;&quot;gitalk-container&quot;的div--&gt;<br>&lt;% if(config[&#39;gitalk_enable&#39;]) &#123; %&gt;<br>               &lt;!-- gitalk 评论框 start --&gt;<br>               &lt;div class&#x3D;&quot;comment&quot;&gt;<br>                   &lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt; <br>               &lt;&#x2F;div&gt;<br>               &lt;!-- gitalk 评论框 end --&gt;<br>               &lt;% &#125; %&gt;<br>               ......<br></code></pre></td></tr></table></figure><p>然后在下方添加Gitalk对应的CSS，JS代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs ejs">&lt;% if(config[&#39;disqus_username&#39;]) &#123; %&gt;<br>                    &lt;!-- disqus 公共JS代码 start (一个网页只需插入一次) --&gt;<br>                    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>                        &#x2F;* * * CONFIGURATION VARIABLES * * *&#x2F;<br>                        var disqus_shortname &#x3D; &quot;&lt;%&#x3D; config[&#39;disqus_username&#39;] %&gt;&quot;;<br>                        var disqus_identifier &#x3D; &quot;&lt;%&#x3D; page.permalink %&gt;&quot;;<br>                        var disqus_url &#x3D; &quot;&lt;%&#x3D; page.permalink %&gt;&quot;;<br><br>                        (function() &#123;<br>                            var dsq &#x3D; document.createElement(&#39;script&#39;); dsq.type &#x3D; &#39;text&#x2F;javascript&#39;; dsq.async &#x3D; true;<br>                            dsq.src &#x3D; &#39;&#x2F;&#x2F;&#39; + disqus_shortname + &#39;.disqus.com&#x2F;embed.js&#39;;<br>                            (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);<br>                        &#125;)();<br>                    &lt;&#x2F;script&gt;<br>                    &lt;!-- disqus 公共JS代码 end --&gt;<br>                    &lt;% &#125; %&gt;<br>                    <br>                      &lt;!-- 此处添加Gitalk代码  --&gt;<br>                    &lt;% if(config[&#39;gitalk_enable&#39;]) &#123; %&gt;<br>                        &lt;!-- Gitalk start --&gt;<br>                        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;<br>                        &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt; <br>                        &lt;script&gt;<br>                            var gitalk  &#x3D; new Gitalk (&#123;<br>                                id: window.location.pathname,   &#x2F;&#x2F; Ensure uniqueness and length less than 50<br>                                clientID: &quot;&lt;%&#x3D; config[&#39;comment_gitalk_clientId&#39;] %&gt;&quot;,<br>                                clientSecret: &quot;&lt;%&#x3D; config[&#39;comment_gitalk_clientSecret&#39;] %&gt;&quot;,<br>                                repo: &quot;&lt;%&#x3D; config[&#39;comment_gitalk_repo&#39;] %&gt;&quot;,<br>                                owner: &quot;&lt;%&#x3D; config[&#39;github_username&#39;] %&gt;&quot;,<br>                                admin: &quot;&lt;%&#x3D; config[&#39;github_username&#39;] %&gt;&quot;,<br>                                id: location.pathname,<br>                                distractionFreeMode: false  &#x2F;&#x2F; Facebook-like distraction free mode<br>                            &#125;)<br>                            gitalk.render(&#39;gitalk-container&#39;)<br>                    &lt;&#x2F;script&gt; <br>                    &lt;!-- Gitalk end --&gt;<br>                    &lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><p>由以上代码可以看到还需要clientID， clientSecret等仓库配置参数，这些参数需要创建一个单独的评论仓库来获取，详情可参考<a href="https://juejin.im/post/5d3ef01ef265da03b81037cd" target="_blank" rel="noopener">静态博客配置 gitalk 评论系统</a>设置。需要注意的是：</p><ul><li><p>Homepage URL: 填写自己的站点域名，如果与来源网站不同，会出现找不到评论的错误页面</p></li><li><p>Authorization callback URL: 这个填写<code>git</code>项目地址</p><p>注册应用成功后再次点击该OAuth App可以看到</p><img src="https://blog-field-1258773891.cos.ap-beijing.myqcloud.com/my-blog/2020/07/29/git-comment.png" alt="git-comment.png" style="zoom: 67%;" /></li></ul><p>然后根据个人配置差异修改站点配置文件<a href="https://github.com/Kaijun/hexo-theme-huxblog/blob/master/_config.yml" target="_blank" rel="noopener">_config.yml</a>，添加如下</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Gitalk settings</span><br><span class="hljs-attr">gitalk_enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">comment_gitalk_clientId:</span> <span class="hljs-string">ce99489e27f66d998fe1</span><br><span class="hljs-attr">comment_gitalk_clientSecret:</span> <span class="hljs-string">fd0bba05f585432aa988cab6c1667a8c5575755f</span><br><span class="hljs-attr">comment_gitalk_repo:</span> <span class="hljs-string">blacktomm.github.io</span><br></code></pre></td></tr></table></figure><p>并替换以上实际参数。</p><h3 id="隐藏底部社交账号头像配置"><a href="#隐藏底部社交账号头像配置" class="headerlink" title="隐藏底部社交账号头像配置"></a>隐藏底部社交账号头像配置</h3><p>个人不太喜欢底部社交账号UI,如果想去除可以尝试如下方法修改 _partial/footer.ejs 或者直接删除对应的代码，以下主要添加了一个配置进行开关, 原始代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">config.twitter_username</span>) &#123; %&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://twitter.com/&lt;%= config.twitter_username %&gt;"</span>&gt;</span><br>                           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa-stack fa-lg"</span>&gt;</span><br>                               <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-circle fa-stack-2x"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                               <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-twitter fa-stack-1x fa-inverse"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                           <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                   <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码意味着一旦设置侧边导航栏社交账号，底部也会显示，因此需要修改代码逻辑：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">config.twitter_username</span> &amp;&amp; <span class="hljs-attr">config.footerSNS</span>) &#123; %&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://twitter.com/&lt;%= config.twitter_username %&gt;"</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa-stack fa-lg"</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-circle fa-stack-2x"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-twitter fa-stack-1x fa-inverse"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到仅添加了逻辑与操作，不设置则默认为false, 如果想要显示底部社交账号，则需要在站点配置文件<a href="https://github.com/Kaijun/hexo-theme-huxblog/blob/master/_config.yml" target="_blank" rel="noopener">_config.yml</a>下添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">footerSNS：</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>该footer.ejs文件夹下其他账号配置类似，添加 <code>&amp;&amp; config.footerSNS</code>代码即可，设置完成后即可部署到github上：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">hexo clean <span class="hljs-comment">//清除缓存</span><br>hexo g -d  <span class="hljs-comment">//生成文件并部署</span><br></code></pre></td></tr></table></figure><p>仔细回想一下，从购买域名到如今博客真正搭出来，到如今已经过去两年了。倒不是说很难搭，一方面总感觉很多代码并不会改，一旦想要更改，总是会遇到各种各样的问题，搜不到解决办法总是会有些不舒服的，随着写的代码越多，理解和更改起来也就自如了些；另一方面是的确没多少干货，虽然看过一些书，但总觉得写不出来太多东西，更像是照搬书上的一些话，缺乏自我的思考。虽然犹豫再三，也还是要做的，也希望能帮到你。</p><p><strong>建议阅读</strong>：</p><ul><li><a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Hexo 搭建个人博客系列</a>：基于Next主题优化及服务器部署</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍了基于HuxBlog所做的一些优化，主要涉及到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;允许博客文章页首图及侧边栏头像链接设置为CDN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加Gitalk评论脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隐藏底部社交账号头像配置&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
    
      <category term="hexo huxblog" scheme="https://blacktomm.github.io/tags/hexo-huxblog/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://blacktomm.github.io/2020/07/29/git-introduce/"/>
    <id>https://blacktomm.github.io/2020/07/29/git-introduce/</id>
    <published>2020-07-29T01:57:00.000Z</published>
    <updated>2020-07-29T10:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git使用指南"><a href="#git使用指南" class="headerlink" title="git使用指南"></a>git使用指南</h1><h2 id="文件的上传与下载"><a href="#文件的上传与下载" class="headerlink" title="文件的上传与下载"></a>文件的上传与下载</h2><p>​    <img src="https://blog-field-1258773891.cos.ap-beijing.myqcloud.com/my-blog/2020/07/29/git.png" alt=""></p><h2 id="如何提交本地工作区文件至远程仓库"><a href="#如何提交本地工作区文件至远程仓库" class="headerlink" title="如何提交本地工作区文件至远程仓库"></a>如何提交本地工作区文件至远程仓库</h2><p>至于如何安装Git可参考<a href="https://backlog.com/git-tutorial/cn/intro/intro2_1.html" target="_blank" rel="noopener">猴子都能懂的Git入门</a>教程1部分，以下介绍两种方法上传文件至github：</p><ol><li><p>第一种是不使用命令，首先登陆github网站，创建一个新的Repository，而后在该库code页面内可看到<code>Upload files</code>按钮，点击将你想要上传的文件夹拖动到方框内等待一段时间即可上传成功。这种做法方便但不适于除个人以外的团队项目</p></li><li><p>第二种依赖于TortoiseGit，即之前建议安装的git汉化版软件</p><ul><li><p>使用前需设置好个人账号及邮箱：鼠标右键-&gt;点击TortoiseGit-&gt;设置，点击Git可以看到<strong>名称</strong>与<strong>Email</strong>标签，填入gtihub账号用户名及申请邮箱即可。也可以通过git bash命令行设置：</p><p>鼠标右键点击git bash通过输入命令设置</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"你的github用户名"</span><br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"注册邮箱"</span><br></code></pre></td></tr></table></figure><p><strong>配置信息查询：</strong></p><p> config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 </p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--system --list查看系统config<br>git<span class="hljs-built_in"> config </span>--global  --list查看当前用户（global）配置<br> git<span class="hljs-built_in"> config </span>--local  --list查看当前仓库配置信息<br></code></pre></td></tr></table></figure></li><li><p>在git bash中创建本地库</p><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"> <span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">test</span>   <span class="hljs-comment">//创建test文件夹</span><br><span class="hljs-keyword">cd</span> <span class="hljs-keyword">test</span><span class="hljs-comment">//进入该文夹</span><br>git init<span class="hljs-comment">//初始化，生成 .git 文件</span><br></code></pre></td></tr></table></figure><p>也可以手动创建该文件夹，在该文件夹下右键点击 <code>git在这里创建版本库</code></p></li><li><p>利用SSH完成git 与gitlab绑定，便于提交代码，可<a href="https://blog.csdn.net/qq_35246620/article/details/69061355" target="_blank" rel="noopener">参考</a></p></li><li><p>backlog推送提交</p><p>用户名及密码输错了如何更改：在控制面板》用户账户》凭据管理器》Windows凭据 下修改即可</p></li></ul></li><li><p><a href="https://blog.csdn.net/question_720520/article/details/81182218" target="_blank" rel="noopener">WSL配置ssh agent连接到github</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs git">mkdir XX      (创建一个空目录 XX指目录名)<br>pwd：          显示当前目录的路径。<br>git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。<br>git add XX        把xx文件添加到暂存区去。<br><br>git commit –m “XX”   提交文件 –m 后面的是注释。<br>git commit --amend   对最近一次提交信息做修正<br>git log -1  提交信息修改后查询<br><br>git status        查看仓库状态<br>git diff  XX      查看XX文件修改了那些内容<br>git diff --cached  对同一文件修改后再次添加到工作区后，与工作区原先版本进行比较<br>git log          查看历史记录<br>git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本<br>                    (如果想回退到100个版本，使用git reset –hard HEAD\~100 )<br>git reset HEAD丢弃当前暂存区所有提交记录<br>git reset HEAD -- file1 file2   丢弃当前暂存区对应文件记录<br>git checkout -- file 将暂存区记录同步到工作区，即意味着工作区文件发生变化,可以丢弃工作区的修改<br><br>cat XX         查看XX文件内容<br>git reflog       查看历史记录的版本号id<br>git checkout — XX  把XX文件在工作区的修改全部撤销。<br>git rm XX          删除XX文件<br><br>git remote add origin https:&#x2F;&#x2F;github.com&#x2F;BlackTomm&#x2F;Learning-center 关联一个远程库<br>git push –u origin master  (第一次要用-u 以后不需要)把当前master分支推送到远程库<br>git clone https:&#x2F;&#x2F;github.com&#x2F;BlackTomm&#x2F;Learning-center  从远程库中克隆<br><br>git checkout –b dev  创建dev分支 并切换到dev分支上<br>git branch  查看当前所有的分支<br>git checkout master 切换回master分支<br>git merge dev    在当前的分支上合并dev分支<br>git branch –d dev 删除dev分支<br>git branch name  创建分支<br><br>git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作<br>git stash list 查看所有被隐藏的文件列表<br>git stash apply 恢复被隐藏的文件，但是内容不删除<br>git stash drop 删除文件<br>git stash pop 恢复文件的同时 也删除文件<br><br>git remote -v 查看远程版本库信息<br>git remote add githup &lt;url&gt; 添加githup远程版本库<br>git fetch github 拉取远程版本库<br>git merge -h 查看合并帮助信息<br>git merge --allow-unrelated-histories githup&#x2F;master 合并githup上的master分支（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）<br>git push githup 推送同步到githup仓库<br>git push origin master  Git会把master分支推送到远程库对应的远程分支上<br></code></pre></td></tr></table></figure></li></ol><p>仓库添加文件</p><figure class="highlight cs"><table><tr><td class="code"><pre><code class="hljs cs">git remote <span class="hljs-keyword">add</span> origin [<span class="hljs-comment">//your github url] //初次需要执行，绑定github推送仓库，后续不需要执行</span><br><br><span class="hljs-comment">//pull those changes</span><br>git pull origin master <br><br><span class="hljs-comment">// or optionally, 'git pull origin master --allow-unrelated-histories' if you have initialized repo in github and also committed locally</span><br><span class="hljs-comment">//now, push your work to your new repo</span><br><br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="多人协作的工作模式："><a href="#多人协作的工作模式：" class="headerlink" title="多人协作的工作模式："></a>多人协作的工作模式：</h3><ol><li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</p><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><ul><li>命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a  -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签</li><li>命令<code>git push origin</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/</code>可以删除一个远程标签。</li></ul><h3 id="github连接问题"><a href="#github连接问题" class="headerlink" title="github连接问题"></a>github连接问题</h3><ol><li><p><a href="https://stackoverflow.com/questions/26953071/github-authentication-failed-github-does-not-provide-shell-access" target="_blank" rel="noopener">Github Authentication Failed - … GitHub does not provide shell access</a></p><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ ssh -T git@github.com<br>Hi lut! You<span class="hljs-symbol">'ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>解决办法：设置远程库url</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">git@</span><span class="hljs-string">github.</span><span class="hljs-string">com:lut/</span><span class="hljs-string">EvolutionApp.</span><span class="hljs-string">git</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git使用指南&quot;&gt;&lt;a href=&quot;#git使用指南&quot; class=&quot;headerlink&quot; title=&quot;git使用指南&quot;&gt;&lt;/a&gt;git使用指南&lt;/h1&gt;&lt;h2 id=&quot;文件的上传与下载&quot;&gt;&lt;a href=&quot;#文件的上传与下载&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="Git" scheme="https://blacktomm.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
